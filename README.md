# DAA Assignment 2: Insertion Sort Analysis and Optimization

### Overview

This project presents an implementation, testing, and empirical analysis of two variants of the **Insertion Sort** algorithm. The goal is to demonstrate how a theoretical improvement impacts practical performance. The project includes:
1.  A **baseline implementation** of the classic Insertion Sort.
2.  An **optimized implementation** that uses binary search to find the element's insertion point.
3.  A detailed metrics collection system (comparisons, shifts, time) for accurate performance analysis.

### Code Structure

The main implementations are located in `src/main/java/`:

*   `algorithms/InsertionSortBasic.java`: The classic implementation of Insertion Sort.
*   `algorithms/InsertionSortOptimized.java`: An improved version utilizing binary search.
*   `metrics/PerformanceTracker.java`: A class for collecting performance metrics.
*   `cli/BenchmarkRunner.java`: A command-line utility for running benchmarks and generating CSV reports.

Unit tests are located in `src/test/java/`:

*   `algorithms/InsertionSortTest.java`: A test suite to verify the correctness of both implementations across various datasets, including edge cases.

### How the Code Works

Each sorting algorithm is implemented as a static `sort` method that accepts an array and a `PerformanceTracker` object. This tracker object is updated on every comparison, shift, or swap, enabling detailed empirical analysis.

*   **`InsertionSortBasic`**: For each element starting from the second, it performs a linear scan through the sorted portion of the array to find the correct position. Elements are shifted to the right to make space.
*   **`InsertionSortOptimized`**: The key difference is the replacement of the linear scan with a **binary search** to find the insertion position. This significantly reduces the number of comparisons, although the number of element shifts remains the same in the worst case.
*   **`BenchmarkRunner`**: Generates arrays of specified sizes (in this case, nearly sorted), runs both algorithm versions on copies of the data, and exports the collected metrics to `benchmark_results.csv`.

### Running the Code

The project uses Maven for compiling, testing, and running benchmarks.

1.  **To compile the project:**
    ```bash
    mvn compile
    ```

2.  **To run the benchmark and generate the CSV report:**
    ```bash
    mvn exec:java -Dexec.mainClass="cli.BenchmarkRunner"
    ```

3.  **To run all tests:**
    ```bash
    mvn test
    ```

### Complexity Analysis

#### `InsertionSortBasic` (Original Version)
*   **Time Complexity**:
    *   **Worst Case**: `Θ(n²)` — occurs when the array is sorted in reverse order. Requires `~n²/2` comparisons and `~n²/2` shifts.
    *   **Average Case**: `Θ(n²)` — for a randomly ordered array.
    *   **Best Case**: `Θ(n)` — occurs when the array is already sorted. Requires `n-1` comparisons and 0 shifts.
*   **Space Complexity**: `O(1)` — the sort is performed in-place.

#### `InsertionSortOptimized` (Optimized Version)
*   **Time Complexity**:
    *   **Comparisons**: Binary search reduces the number of comparisons to `Θ(n log n)`.
    *   **Shifts**: In the worst and average cases, the number of shifts remains `Θ(n²)`, as elements must still be physically moved.
    *   **Overall Complexity**: `Θ(n²)` — the asymptotics are determined by the number of shifts, not comparisons.
*   **Space Complexity**: `O(1)` — the sort is also performed in-place.

### Performance Comparison: Original vs. Optimization

| Metric | `InsertionSortBasic` | `InsertionSortOptimized` | Optimization Result |
| :--- | :--- | :--- | :--- |
| **Comparisons** | `Θ(n²)` | `Θ(n log n)` | **Significant Improvement** |
| **Shifts/Swaps** | `Θ(n²)` | `Θ(n²)` | **No Change** |
| **Total Time** | `Θ(n²)` | `Θ(n²)` | **Slight Improvement** |

**Theoretical Takeaway:** The optimization significantly reduces the number of comparison operations, which is a bottleneck in the basic version. However, the overall asymptotic complexity of `Θ(n²)` is preserved because it is bounded by the data shifting operations.

**Empirical Results:** The data generated by `BenchmarkRunner` and saved in `benchmark_results.csv` confirms the theory. Performance plots show that `InsertionSortOptimized` consistently runs faster than `InsertionSortBasic`, although both algorithms exhibit quadratic growth in execution time. The time difference becomes more pronounced on larger arrays, where the cost of `n²` comparisons becomes dominant.

### Partner's Algorithm Analysis
1. Algorithm Overview
   The submitted code provides two implementations of the Selection Sort algorithm: a ClassicSelectionSort and
   an OptimizedSelectionSort. This algorithm works by repeatedly finding the minimum element from the unsorted
   part of the array and placing it at the beginning of the unsorted part. This process is repeated until the entire array is sorted.
2. Asymptotic Complexity Analysis
   Time Complexity:
   Best, Worst, and Average Case: Θ(n²) - Selection Sort's performance is not dependent on the initial order of
   the data. The nested loops structure ensures that it always performs the full set of comparisons to find
   the minimum element in the remainder of the array. The number of comparisons is always n(n-1)/2, leading
   to a consistent quadratic time complexity. The algorithm is not adaptive.
   Space Complexity:
   Θ(1) - Both implementations are in-place and use a constant amount of extra memory for variables.
3. Code Review and Analysis of Optimization
   Bakdaulet provided two distinct, clean, and correct implementations for comparison.
   ClassicSelectionSort: This is a standard, textbook implementation. It correctly finds the minimum element's
   index and performs a swap in every pass of the outer loop.
   OptimizedSelectionSort: This version introduces a simple yet effective optimization. Before performing the swap,
   it checks if the found minimum element is already in its correct position:

if (minIndex != i) {
// perform swap
}


### Conclusion

This project demonstrates both the theoretical and practical value of algorithmic optimization. Switching from a linear scan to a binary search in Insertion Sort led to a measurable performance improvement by reducing comparisons, even though the overall quadratic time complexity remained due to the data shifting bottleneck. The empirical tests align perfectly with the theoretical analysis.